package org.erights.e.elang.syntax;

/*
The contents of this file are subject to the Electric Communities E Open
Source Code License Version 1.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License
at http://www.communities.com/EL/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is the Distributed E Language Implementation, released
July 20, 1998.

The Initial Developer of the Original Code is Electric Communities.
Copyright (C) 1998 Electric Communities. All Rights Reserved.

Contributor(s): ______________________________________.
*/

import org.erights.e.develop.assertion.T;
import org.erights.e.develop.exception.ExceptionMgr;
import org.erights.e.elang.evm.AtomicExpr;
import org.erights.e.elang.evm.AuditorExprs;
import org.erights.e.elang.evm.CallExpr;
import org.erights.e.elang.evm.EExpr;
import org.erights.e.elang.evm.EMatcher;
import org.erights.e.elang.evm.EMethod;
import org.erights.e.elang.evm.ENode;
import org.erights.e.elang.evm.GuardedPattern;
import org.erights.e.elang.evm.LiteralExpr;
import org.erights.e.elang.evm.MetaContextExpr;
import org.erights.e.elang.evm.MetaStateExpr;
import org.erights.e.elang.evm.NounExpr;
import org.erights.e.elang.evm.Pattern;
import org.erights.e.elang.evm.QuasiLiteralExpr;
import org.erights.e.elang.evm.QuasiLiteralPatt;
import org.erights.e.elang.evm.QuasiPatternExpr;
import org.erights.e.elang.evm.QuasiPatternPatt;
import org.erights.e.elang.evm.SimpleNounExpr;
import org.erights.e.elang.evm.SlotExpr;
import org.erights.e.elang.evm.SlotPattern;
import org.erights.e.elang.evm.StaticScope;
import org.erights.e.elang.evm.VarPattern;
import org.erights.e.elang.interp.ResourceUriGetter;
import org.erights.e.elang.interp.Rune;
import org.erights.e.elang.visitors.RenameVisitor;
import org.erights.e.elib.base.ValueThunk;
import org.erights.e.elib.oldeio.TextWriter;
import org.erights.e.elib.prim.E;
import org.erights.e.elib.prim.JavaMemberNode;
import org.erights.e.elib.tables.ConstMap;
import org.erights.e.elib.tables.EList;
import org.erights.e.elib.tables.FlexList;
import org.erights.e.elib.tables.FlexMap;
import org.erights.e.elib.tables.Twine;
import org.erights.e.meta.java.math.EInt;
import org.erights.e.meta.java.util.PropertiesSugar;
import org.quasiliteral.astro.Astro;
import org.quasiliteral.syntax.LexerFace;
import org.quasiliteral.syntax.URIKit;

import java.io.IOException;
import java.net.URL;
import java.util.Properties;

/**
 * Build Expanded-E parse-trees.
 *
 * @author Mark S. Miller
 */
public class ENodeBuilder extends BaseENodeBuilder implements EBuilder {

    /*
     * These are the names from the universalScope generated by the E
     * expansion. Because we don't (yet?) support hygenic syntactic scopes, all
     * these names must be unshadowable, which must be coordinated with the
     * lists in ScopeSetup.
     */

    static private final EExpr NULL = noun("null");

    static final EExpr FALSE = noun("false");

    static final EExpr TRUE = noun("true");

    static private final EExpr THROW = noun("throw");

    static private final EExpr LOOP = noun("__loop");


    static private final EExpr MAKE_LIST = noun("__makeList");

    static private final EExpr MAKE_MAP = noun("__makeMap");

    static private final EExpr MAKE_PROT = noun("__makeProtocolDesc");

    static private final EExpr MAKE_MSG = noun("__makeMessageDesc");

    static private final EExpr MAKE_PARAM = noun("__makeParamDesc");

//    static private final EExpr SETTABLE = noun("settable");
//
//    static private final EExpr DEFINESLOT = noun("__defineSlot");

    static private final EExpr ANY = noun("any");

    static private final EExpr VOID = noun("void");


    static private final EExpr BOOLEAN = noun("boolean");

    static private final EExpr MAKE_ORDERED_SPACE = noun("__makeOrderedSpace");

    static private final EExpr GUARD = noun("Guard");

    static private final EExpr REQUIRE = noun("require");

    static private final EExpr __MAKE_VERB_FACET = noun("__makeVerbFacet");

    static private final EExpr __BIND = noun("__bind");
    static private final EExpr __EMPTY = noun("__Empty");
    static private final EExpr __EXTRACT = noun("__extract");
    static private final EExpr __MATCHBIND = noun("__matchBind");
    static private final EExpr __SPLITLIST = noun("__splitList");
    static private final EExpr __IS = noun("__is");
    static final EExpr __TEST = noun("__Test");

    static private final EExpr __SUCHTHAT = noun("__suchThat");

    static final LiteralExpr __RIGHT_SKIPPED =
      new LiteralExpr(null, "right side skipped", null);

    /*
    * These are the names from the safeScope generated by the E expansion,
    * which, therefore, must be unshadowable.
    */

    static private final EExpr EQUALIZER = noun("__equalizer");

    static private final EExpr COMPARER = noun("__comparer");

    static final EExpr REF = noun("Ref");

    static private final EExpr EE = noun("E");

    static private final EExpr PROMISE_ALL_FULFILLED =
      noun("promiseAllFulfilled");

    /*
     * These are names generated by the E expansion, but they are not bound
     * in the safe scope. Rather, they are intended to act in a non-hygenic
     * manner: for, while, to, etc... generate defining occurrences of these,
     * and break, continue, return generate use occurrences. The use occurrence
     * is intended to refer to the lexically apparent defining occurrence by
     * conventional pre-hygenic rules.
     * <p>
     * In short, these names are and must be shadowable.
     */

    static private final EExpr __BREAK = noun("__break");

    static private final EExpr __CONTINUE = noun("__continue");

    static private final EExpr __RETURN = noun("__return");


    static private final String BAD_FOR =
      "For-loop body isn't valid after for-loop exits.";

    static private final EExpr[] NO_EXPRS = {};

    static private final Pattern[] NO_PATTERNS = {};

    static private Object take(FlexMap decl, String name) {
        Object result = decl.fetch(name, ValueThunk.NULL_THUNK);
        if (null == result) {
            T.fail("internal: " + name + " attribute was null");
        }
        decl.removeKey(name, true);
        return result;
    }

    static private Object optTake(FlexMap decl, String name) {
        Object result = decl.fetch(name, ValueThunk.NULL_THUNK);
        decl.removeKey(name);
        return result;
    }

    static private EExpr[] takeExprs(FlexMap decl, String name) {
        EExpr[] result = (EExpr[])optTypedArray(optTake(decl, name),
                                                EExpr.class);
        if (null == result) {
            result = NO_EXPRS;
        }
        return result;
    }

    /**
     *
     */
    private final HilbertHotel myHilbert = new HilbertHotel();

    /**
     *
     */
    public ENodeBuilder(ConstMap props, LexerFace lexer, TextWriter warns) {
        super(props, lexer, warns);
    }

    /**
     *
     */
    public EExpr getNULL() {
        return NULL;
    }

    /**
     *
     */
    public EExpr getVOID() {
        return VOID;
    }

    /**
     *
     */
    public EExpr get__BREAK() {
        return __BREAK;
    }

    /**
     *
     */
    public EExpr get__CONTINUE() {
        return __CONTINUE;
    }

    /**
     *
     */
    public EExpr get__RETURN() {
        return __RETURN;
    }

    /**
     *
     */
    public EExpr assign(Object lValue, Object rValue) {

        EExpr lval = (EExpr)lValue;
        EExpr rval = forValue(rValue, null);

        /*
         *  x ":=" z
         */
        if (lval instanceof AtomicExpr) {

            /* the base case */
            return super.assign(lval, rval);
        }
        if (lval instanceof CallExpr) {
            CallExpr ce = (CallExpr)lval;
            EExpr recip = ce.getRecipient();
            String verb = ce.getVerb();
            EExpr[] args = ce.getArgs();

            /*
             *  x.get(y) := z         expands to  x.put(y, z)
             *  x.get(y1, y2) := z    expands to  x.put(y1, y2, z)
             *  x.getName() := z      expands to  x.setName(z)
             *  x.run(y) := z         expands to  x.setRun(y, z)
             *
             * Remember that x[y]     expands to  x.get(y)
             *               x::name  expands to  x.__getPropertySlot("name")\
             *                                     .get()
             * and           x(y)     expands to  x.run(y)
             * so all are valid lvalues
             */
            Astro newVerb = null;
            if ("get".equals(verb)) {
                newVerb = ident(lval, "put");

            } else if (verb.startsWith("get")) {
                newVerb = ident(lval, "set" + verb.substring("get".length()));

            } else if (verb.startsWith("__get")) {
                newVerb =
                  ident(lval, "__set" + verb.substring("__get".length()));

            } else if ("run".equals(verb)) {
                newVerb = ident(lval, "setRun");
            }
            if (null != newVerb) {
                EExpr[] newArgs = new EExpr[args.length + 1];
                System.arraycopy(args, 0, newArgs, 0, args.length);
                Astro ares = newTemp("ares");
                newArgs[args.length] = kdef(finalPattern(ares), rval);
                return sequence(call(recip, newVerb, newArgs), noun(ares));
            }
        }
        syntaxError(lval,
                    "Assignment can only be done to nouns " +
                      "and collection elements");
        return null; //keep compiler happy
    }

    /**
     * Return a pair of an optional prelude expression and an access
     * expression, used to access or modify an lValue without recomputing the
     * lValue expression.
     * <p/>
     * In expanding<pre>
     *     x[foo()][bar()] += 3</pre>
     * it's important that <tt>x[foo()]</tt> and <tt>bar()</tt> only be
     * evaluated once. This evaluation happens in the prelude, leaving the
     * resulting values in temporary variables, let's say <tt>t1</tt> and
     * <tt>t2</tt> used by the access expression.
     * <p/>
     * The access expression would then be <tt>t1[t2]</tt>, ie,
     * <tt>t1.get(t2)</tt>. By the assignment rules, when such an expression
     * appears on the left side of an assignment, it gets transformed
     * approximately into <tt>t1.put(t2, newValue)</tt>. (Actually, the
     * assignment transform also arranges for the value of the assignment to be
     * the value the rValue evaluated to.)
     * <p/>
     * lValuePair can only be applied to NounExprs and CallExprs.
     */
    private EExpr[] lValuePair(EExpr lValue) {

        if (lValue instanceof NounExpr) {
            //A NounExpr needs no prelude, and is its own access expression.
            return new EExpr[]{null, lValue};

        } else if (lValue instanceof CallExpr) {
            /*
             * x.v(y...).verb= z
             * expands to
             *      x into r
             *      y into a0
             *      ...
             *      r.v(a0...) := r.v(a0...).verb(z)
             */
            CallExpr lval = (CallExpr)lValue;
            EExpr recip = lval.getRecipient();
            EExpr[] args = lval.getArgs();

            Astro r = newTemp("recip");
            EExpr prelude = kdef(finalPattern(r), recip);
            EExpr tempRecip = noun(r);

            EExpr[] tempArgs = new EExpr[args.length];
            for (int i = 0; i < args.length; i++) {
                Astro a = newTemp("arg");
                prelude = sequence(prelude, kdef(finalPattern(a), args[i]));
                tempArgs[i] = noun(a);
            }
            lValue = call(tempRecip, lval, lval.getVerb(), tempArgs);

            return new EExpr[]{prelude, lValue};

        } else if (lValue instanceof QuasiLiteralExpr) {

            syntaxError(lValue,
                        "Can't use update-assign syntax on a \"$\"-hole. " +
                          "Use explicit \":=\" syntax instead");
            return null; //keep compiler happy

        } else if (lValue instanceof QuasiPatternExpr) {

            syntaxError(lValue,
                        "Can't use update-assign syntax on a \"@\"-hole. " +
                          "Use explicit \":=\" syntax instead");
            return null; //keep compiler happy

        } else {
            syntaxError(lValue, "Can only update-assign nouns and calls");
            return null; //keep compiler happy
        }
    }

    /**
     *
     */
    public EExpr update(Object lValue, Object verb, Object rnValue) {

        Astro verbName;
        if (verb instanceof Astro) {
            //Must handle IDs or VerbAssigns
            Astro arg0 = ((Astro)((Astro)verb).getArgs().get(0));
            verbName = ident(verb, arg0.getOptString());
        } else {
            String str = (String)verb;
            verbName = ident(str);
        }
        EExpr[] pair = lValuePair((EExpr)lValue);
        EExpr optPrelude = pair[0];
        lValue = pair[1];

        EExpr result = assign(lValue, call(lValue, verbName, rnValue));
        if (null != optPrelude) {
            result = sequence(optPrelude, result);
        }
        return result;
    }

    /**
     *
     */
    public EExpr slotExpr(Object poser, Object eExpr) {
        if (!(eExpr instanceof AtomicExpr)) {
            reserved(poser, "unary prefix '&' applied to non-noun lValue");
        }
        return super.slotExpr(poser, eExpr);
    }

    /**
     *
     */
    public EExpr call(Object recipientExpr,
                      Object poser,
                      String verb,
                      Object args) {
        return call(recipientExpr, ident(poser, verb), args);
    }

    /**
     *
     */
    public EExpr send(Object recipientExpr, Object verb, Object args) {
        return call(EE,
                    ident(verb, "send"),
                    list(recipientExpr, litStr(verb), tuple(args)));
    }

    /**
     *
     */
    public EExpr send(Object recipientExpr,
                      Object poser,
                      String verb,
                      Object args) {
        return send(recipientExpr, ident(poser, verb), args);
    }

    /**
     *
     */
    public EExpr binop(Object recipientExpr,
                       Object poser,
                       String verb,
                       Object arg) {
        return call(recipientExpr, poser, verb, list(arg));
    }

    /**
     *
     */
    public EExpr not(Object poser, Object x) {
        return call(x, poser, "not", list());
    }

    /**
     *
     */
    String keywordStr(Object identOrStr) {
        if (null == identOrStr) {
            return null;
        } else if (identOrStr instanceof String) {
            return (String)identOrStr;
        } else {
            Astro astro = ((Astro)identOrStr);
            return astro.getTag().getTagName();
        }
    }

    /**
     *
     */
    public EExpr doMeta(Object keyword, Object verb, Object args) {
        String kword = keywordStr(keyword);
        String verbStr = idStr(verb).intern();
        EExpr[] exprs = optExprs(args);
        if ("meta".equalsIgnoreCase(kword)) {
            if (0 == exprs.length) {
                if ("getState" == verbStr || "scope" == verbStr) {
                    // XXX meta.scope() must be deprecated somehow.
                    // You should use meta.getState() instead.
                    pocket(verb, "meta-scope");
                    //XXX should add a metaStateExpr() to BaseEBuilder and call
                    //it here
                    return new MetaStateExpr(null, null);
                } else if ("context" == verbStr) {
                    // Out of the pccket, since the interface expansion now
                    // uses it, so it must be an official part of the
                    // language.
//                    pocket("meta-scope");

                    //XXX should add a metaSynEnvExpr() to BaseEBuilder and
                    //call it here
                    return new MetaContextExpr(null, null);
                }
            } else if (2 == exprs.length) {
                if ("eval" == verbStr) {
                    reserved(verb, "reified evaluation");
                }
            }
            syntaxError(verb,
                        "unrecognized meta." + verbStr + "/" + exprs.length);
        } else if ("pragma".equalsIgnoreCase(kword)) {
            if (1 == exprs.length) {
                if ("syntax" == verbStr) {
                    LiteralExpr lit = (LiteralExpr)exprs[0];
                    String path = "org/erights/e/elang/syntax/syntax-props-" +
                      (String)lit.getValue() + ".txt";

                    Properties eprops = new Properties();
                    URL synPropsURL = (URL)ResourceUriGetter.THE_ONE.get(path);
                    try {
                        PropertiesSugar.loadFromURL(eprops, synPropsURL);
                    } catch (IOException e) {
                        throw ExceptionMgr.asSafe(e);
                    }
                    ConstMap newProps = ConstMap.fromProperties(eprops);
                    myProps = newProps.or(myProps);
                    return NULL;

                } else if ("enable" == verbStr) {
                    LiteralExpr lit = (LiteralExpr)exprs[0];
                    String propName = "e.enable." + (String)lit.getValue();
                    String propVal =
                      (String)myProps.fetch(propName, new ValueThunk("false"));
                    propVal = propVal.intern();
                    if ("true" == propVal) {
                        //already enabled. ignore.
                        return NULL;
                    } else if ("warn" == propVal) {
                        //enabling it turns off warnings.
                        myProps = myProps.with(propName, "true");
                        return NULL;
                    } else if ("allow" == propVal) {
                        myProps = myProps.with(propName, "true");
                        return NULL;
                    } else if ("false" == propVal) {
                        syntaxError(verb,
                                    "The optional " + propName + " feature " +
                                      Rune.SYN_PROPS_EXPLAIN +
                                      " is currently not 'allow'ed.");
                    }
                } else if ("warn" == verbStr) {
                    LiteralExpr lit = (LiteralExpr)exprs[0];
                    String propName = "e.enable." + (String)lit.getValue();
                    String propVal =
                      (String)myProps.fetch(propName, new ValueThunk("false"));
                    propVal = propVal.intern();
                    if ("true" == propVal) {
                        //Turns on warnings
                        myProps = myProps.with(propName, "warn");
                        return NULL;
                    } else if ("warn" == propVal) {
                        //already warning. ignore.
                        return NULL;
                    } else if ("allow" == propVal) {
                        myProps = myProps.with(propName, "warn");
                        return NULL;
                    } else if ("false" == propVal) {
                        syntaxError(verb,
                                    "The optional " + propName + " feature " +
                                      Rune.SYN_PROPS_EXPLAIN +
                                      " is currently not 'allow'ed.");
                    }
                } else if ("disable" == verbStr) {
                    LiteralExpr lit = (LiteralExpr)exprs[0];
                    String propName = "e.enable." + (String)lit.getValue();
                    String propVal =
                      (String)myProps.fetch(propName, new ValueThunk("false"));
                    propVal = propVal.intern();
                    if ("true" == propVal) {
                        //If it was enabled, it can still be re-enabled
                        myProps = myProps.with(propName, "allow");
                        return NULL;
                    } else if ("warn" == propVal) {
                        //If it was warning, it can still be re-enabled
                        myProps = myProps.with(propName, "allow");
                        return NULL;
                    } else if ("allow" == propVal) {
                        //Already disabled but allowed. Ignore.
                        return NULL;
                    } else if ("false" == propVal) {
                        //already disabled. Ignore.
                        return NULL;
                    }
                }
            }
            syntaxError(verb,
                        "unrecognized pragma." + verbStr + "/" + exprs.length);
        } else {
            syntaxError(verb, "internal: unrecognized " + kword);
        }
        return null; //keep compiler happy
    }

    /**
     *
     */
    public EExpr doMeta(Object keyword,
                        Object poser,
                        String verb,
                        Object args) {
        return doMeta(keyword, ident(poser, verb), args);
    }

    /**
     *
     */
    public EExpr doMetaSend(Object keyword, Object verb, Object args) {
        String kword = keywordStr(keyword);
        String verbStr = idStr(verb).intern();
        EExpr[] exprs = optExprs(args);
        if ("meta".equalsIgnoreCase(kword)) {
            if (2 == exprs.length) {
                if ("eval" == verbStr) {
                    reserved(verb, "remote evaluation");
                }
            }
            syntaxError(verb, "unrecognized meta <- " + verbStr + "/" + exprs
              .length);
        } else if ("pragma".equalsIgnoreCase(kword)) {
            syntaxError(verb, "unrecognized pragma <- " + verbStr + "/" + exprs
              .length);
        } else {
            syntaxError(verb, "internal: unrecognized " + kword);
        }
        return null; //keep compiler happy
    }

    /**
     *
     */
    public EExpr doMetaSend(Object keyword,
                            Object poser,
                            String verb,
                            Object args) {
        return doMetaSend(keyword, ident(poser, verb), args);
    }

    /**
     *
     */
    public EExpr doMetaProp(Object keyword, Object propName) {
        String str = JavaMemberNode.asGetterVerb(idStr(propName));
        return doMeta(keyword, ident(propName, str), list());
    }

    /**
     *
     */
    public EExpr kdef(Object pattern, Object rValue) {
        return kerneldef(pattern, null, rValue);
    }

    /**
     * Expand a left-pattern and an rValue that might cause a circularity into
     * a sequence of expressions without this circularity, except that the
     * place for the expression itself has a null as a placeholder.
     * <pre>
     * result[0..!numVars]      = ...Ref.promise()...
     * result[numVars]          = null expands to e.g.,
     *                                def res := (def patt := rVal)
     * result[numVars+1..!last] = ..resolve..
     * result[last]             = res
     * </pre>
     */
    private EExpr[] antiCycle(FlexMap conflicts) {
        int numVars = conflicts.size();
        if (0 >= numVars) {
            return null;
        }
        EExpr[] result = new EExpr[numVars * 2 + 2];
        String[] keys = (String[])conflicts.getKeys(String.class);
        for (int i = 0; i < numVars; i++) {
            String oldNameStr = keys[i];
            Astro newName = newTemp(oldNameStr);
            Astro newNameR = newTemp(oldNameStr + "R");
            conflicts.put(oldNameStr, newName.getOptArgString(EParser.ID));
            /*
             * def [newName,newNameR] := Ref.promise()
             */
            Pattern[] pair = {finalPattern(newName), finalPattern(newNameR)};
            result[i] =
              kdef(listPattern(pair), call(REF, NO_POSER, "promise", list()));
            /*
             * newNameR.resolve(oldName)
             */
            result[numVars + 1 + i] = call(noun(newNameR),
                                           NO_POSER,
                                           "resolve",
                                           list(noun(oldNameStr)));
        }
        Astro resName = newTemp("res");
        result[numVars] = null;
        result[result.length - 1] = noun(resName);
        return result;
    }

    /**
     *
     */
    private void ensureEmpty(ConstMap conflicts, String msg) {
        if (1 <= conflicts.size()) {
            ENode node = ((ENode[])conflicts.getValues(ENode.class))[0];
            syntaxError(node, msg + ": " + E.toString(conflicts.getKeys()));
        }
    }

    /**
     *
     */
    private void ensureCommutes(StaticScope left, StaticScope right) {
        ensureEmpty(left.outNames().and(right.namesUsed()),
                    "Use on right isn't really in scope of definition");
        ensureEmpty(right.outNames().and(left.namesUsed()),
                    "Use on left would get captured by definition on right");
    }

    /**
     *
     */
    public EExpr define(Object pattern, Object rValue) {
        return define(pattern, null, rValue);
    }

    /**
     *
     */
    public EExpr define(Object pattern, Object optEjectorExpr, Object rValue) {
        Pattern patt = (Pattern)pattern;
        StaticScope pattScope = patt.staticScope();
        ConstMap defPatts = pattScope.defNames();
        ConstMap varPatts = pattScope.varNames();
        EExpr rVal = forValue(rValue, null);
        StaticScope rValScope = rVal.staticScope();
        EExpr optEj = null;
        if (null != optEjectorExpr) {
            optEj = forValue(optEjectorExpr, null);
            rValScope = optEj.staticScope().add(rValScope);
        }
        ConstMap rValUsed = rValScope.namesUsed();
        ConstMap badConflicts = varPatts.and(rValUsed);
        ensureEmpty(badConflicts, "Circular 'var' definition not allowed");
        ConstMap shadows = pattScope.namesUsed().and(rValScope.outNames());
        ensureEmpty(shadows, "Pattern may not use var defined on the right");
        FlexMap conflicts = defPatts.and(rValUsed).diverge();
        int numVars = conflicts.size();
        if (0 >= numVars) {
            return kerneldef(patt, optEj, rVal);
        }
        EExpr[] parts = antiCycle(conflicts);
        RenameVisitor renamer = new RenameVisitor(conflicts);
        if (null != optEj) {
            optEj = renamer.xformEExpr(optEj);
        }
        rVal = renamer.xformEExpr(rVal);
        NounExpr resNoun = (NounExpr)parts[parts.length - 1];
        Pattern resPatt = finalPattern(resNoun.getName());
        parts[numVars] = kdef(resPatt, kerneldef(patt, optEj, rVal));
        return sequence(parts);
    }

    /**
     * When an at-hole is '@<ident>' or '@_'
     */
    public Pattern atNoun(Object token) {
        String str = ((Astro)token).getOptArgString(EParser.AtIdent);
        str = HilbertHotel.rename(str);
        if ("_".equals(str)) {
            return ignore();
        }
        return finalPattern(str);
    }

    /**
     * When a dollar-hole is '$<ident>'
     */
    public EExpr dollarNoun(Object token) {
        String str = ((Astro)token).getOptArgString(EParser.DollarIdent);
        str = HilbertHotel.rename(str);
        return new SimpleNounExpr(optSpan(token),
                                  str,
                                  null);
    }

    /**
     * Makes an identifier token whose value is 'newStr', and whose SourceSpan
     * is derived from 'poser'.
     * <p/>
     * 'poser' might be null, a String, an identifier token (an Astro), or a
     * CallExpr.<ul> <li>If it's null or a String, the SourceSpan is empty.
     * <li>If it's an Astro or a ParseNode, then its SourceSpan is used. </ul>
     */
    public Astro ident(Object poser, String newStr) {
        return myLexer.composite(EParser.ID, newStr, optSpan(poser));
    }

    /**
     * generate 'unique' temporary variable names for transformations.
     * <p/>
     * Suffix must be odd to make room for the new guests at the Hilbert
     * Hotel.
     *
     * @param identOrString Either an Astro representing an identifier, or a
     *                      String whose value is an identifier
     * @return The variable name for use in the program.
     * @see #varName(Object)
     * @see HilbertHotel#newTemp(String)
     */
    Astro newTemp(Object identOrString) {
        String str = idStr(identOrString);
        return ident(identOrString, myHilbert.newTemp(str));
    }

    /**
     * Make vacancies for new temporary variable names.
     *
     * @param ident An Astro representing the identifier as it appears in the
     *              source code.
     * @return The variable name as far as the program is concerned. So long as
     *         id doesn't have the form of a temporary variable name, this will
     *         be the same as id.
     * @see HilbertHotel#rename(String)
     */
    public Astro varName(Object ident) {
        String str = idStr(ident);
        return ident(ident, HilbertHotel.rename(str));
    }

    /**
     * Mangles an identifier into a variable name by appending a known suffix.
     *
     * @param ident An Astro representing the identifier as it appears in the
     *              source code.
     * @return The resulting variable name for use in the program.
     */
    public Astro mangle(Object ident, String suffix) {
        String str = ((Astro)ident).getOptArgString(EParser.ID);
        return ident(ident, str + suffix);
    }

    /**
     * A forward declaration. <p>
     * <p/>
     * "def name" expands to <pre>
     *     (def [name, name__Resolver] := Ref.promise(); name__Resolver)
     * </pre>
     * The value of a "def name" expression is the Resolver that will resolve
     * 'name', so, for example, '(def name)' can be used in an argument
     * position both to define 'name' and to pass the Resolver as an argument
     * to someone who will resolve it.
     */
    public EExpr forward(Object identOrStr) {
        Astro name = ident(identOrStr);
        Astro nameR = mangle(name, "__Resolver");
        return sequence(kdef(listPattern(list(finalPattern(name),
                                              finalPattern(nameR))),
                             call(REF, identOrStr, "promise", list())),
                        noun(nameR));
    }

    /**
     * delegate{expr} expands to match pair { E.callWithPair(expr, pair) }
     */
    public EMatcher delegatex(Object bodyExpr) {
        Astro pair = newTemp("pair");

        return matcher(finalPattern(pair),
                       call(EE,
                            NO_POSER,
                            "callWithPair",
                            list(bodyExpr, noun(pair))));
    }

    /**
     *
     */
    public EExpr escape(Object pattern, Object bodyExpr, Object optCatcher) {
        if (null == optCatcher) {
            return escape(pattern, bodyExpr, null, null);
        }
        EMatcher matcher = (EMatcher)optCatcher;
        return escape(pattern,
                      bodyExpr,
                      matcher.getPattern(),
                      matcher.getBody());
    }


    /**
     *
     */
    public EExpr ejector(Object ejNoun) {
        return call(ejNoun, NO_POSER, "run", list());
    }

    /**
     *
     */
    public EExpr ejector(Object ejNoun, Object valExpr) {
        return call(ejNoun, NO_POSER, "run", list(valExpr));
    }

    /*
     *
     */
    public EExpr forx(Object assoc,
                      Object collExpr,
                      Object mBody,
                      Object optCatcher) {
        EExpr bodyExpr = forValue(mBody, StaticScope.EmptyScope);

        Astro fTemp = newTemp("validFlag");
        Astro kTemp = newTemp("key");
        Astro vTemp = newTemp("value");

        Assoc patterns = (Assoc)assoc;
        Pattern key = (Pattern)patterns.key();
        Pattern value = (Pattern)patterns.value();
        EExpr coll = forValue(collExpr, bodyExpr.staticScope());
        ensureCommutes(key.staticScope().add(value.staticScope()),
                       coll.staticScope());

        MsgPatt mpatt = methHead(NO_POSER,
                                 "run",
                                 list(finalPattern(kTemp),
                                      finalPattern(vTemp)),
                                 null);

        EExpr body = sequence(call(REQUIRE,
                                   "run",
                                   list(noun(fTemp), literal(BAD_FOR))),
                              ifx(condAnd(matchBind(noun(kTemp),
                                                    NO_POSER,
                                                    key),
                                          NO_POSER,
                                          matchBind(noun(vTemp),
                                                    NO_POSER,
                                                    value)),
                                  escape(finalPattern("__continue"),
                                         sequence(bodyExpr, NULL),
                                         null)));

        EExpr closure = object(" For-loop body ",
                               ignoreOName(),
                               null,
                               AuditorExprs.NO_AUDITORS,
                               methScriptDecl(mpatt, body, false));

        return escape(finalPattern("__break"),
                      sequence(kdef(varPattern(fTemp), TRUE),
                               tryx(call(coll,
                                         coll,
                                         "iterate",
                                         list(closure)),
                                    null,
                                    assign(noun(fTemp), FALSE)),
                               NULL),
                      optCatcher);
    }

    /**
     *
     */
    public EExpr accumulate(Object starterExpr, Object accumulator) {
        Object[] pair = (Object[])accumulator;
        Astro tempName = (Astro)pair[0];
        Object accumExpr = pair[1];
        return sequence(kdef(varPattern(tempName), starterExpr),
                        accumExpr,
                        noun(tempName));
    }

    /**
     *
     */
    public Object[] accumFor(Object assoc, Object collExpr, Object accumBody) {
        Object[] pair = (Object[])accumBody;
        Astro tempName = (Astro)pair[0];
        Object accumExpr = pair[1];
        return new Object[]{tempName, forx(assoc, collExpr, accumExpr, null)};
    }

    /**
     *
     */
    public Object[] accumIf(Object condExpr, Object accumBody) {
        Object[] pair = (Object[])accumBody;
        Astro tempName = (Astro)pair[0];
        Object accumExpr = pair[1];
        return new Object[]{tempName, ifx(condExpr, accumExpr)};
    }

    /**
     *
     */
    public Object[] accumWhile(Object condExpr, Object accumBody) {
        Object[] pair = (Object[])accumBody;
        Astro tempName = (Astro)pair[0];
        Object accumExpr = pair[1];
        return new Object[]{tempName, whilex(condExpr, accumExpr, null)};
    }

    /**
     *
     */
    public Object[] accumBody(Object verb, Object rnValue) {
        Astro tempName = newTemp("accum");
        return new Object[]{tempName, update(noun(tempName), verb, rnValue)};
    }

    /**
     *
     */
    public EExpr ifx(Object condExpr, Object thenExpr) {
        return ifx(condExpr, thenExpr, NULL);
    }

    /**
     *
     */
    public EExpr lessThan(Object x, Object poser, Object y) {
        return call(COMPARER, poser, "lessThan", list(x, y));
    }

    /**
     *
     */
    public EExpr leq(Object x, Object poser, Object y) {
        return call(COMPARER, poser, "leq", list(x, y));
    }

    /**
     *
     */
    public EExpr asBigAs(Object x, Object poser, Object y) {
        return call(COMPARER, poser, "asBigAs", list(x, y));
    }

    /**
     *
     */
    public EExpr geq(Object x, Object poser, Object y) {
        return call(COMPARER, poser, "geq", list(x, y));
    }

    /**
     *
     */
    public EExpr greaterThan(Object x, Object poser, Object y) {
        return call(COMPARER, poser, "greaterThan", list(x, y));
    }

    /**
     *
     */
    public EExpr till(Object start, Object poser, Object bound) {
        return call(MAKE_ORDERED_SPACE, poser, "op__till", list(start, bound));
    }

    /**
     *
     */
    public EExpr thru(Object start, Object poser, Object stop) {
        return call(MAKE_ORDERED_SPACE, poser, "op__thru", list(start, stop));
    }

    /**
     * [a => b, c => d]  expands to  __makeMap fromPairs([[a, b], [c, d])
     * <p/>
     * This exapansion satisfies the requirement that it preserves order.
     */
    public EExpr map(Object assocList) {
        Assoc[] assocs = (Assoc[])optTypedArray(assocList, Assoc.class);
        FlexList pairs = list();
        for (int i = 0; i < assocs.length; i++) {
            Assoc assoc = assocs[i];
            pairs = with(pairs, tuple(list(assoc.key(), assoc.value())));
        }
        return call(MAKE_MAP, NO_POSER, "fromPairs", list(tuple(pairs)));
    }

    /**
     *
     */
    public Pattern mapPattern(Object assocList, Object optRestPatt) {
        Pattern result;
        if (null == optRestPatt) {
            // :Empty
            result = ignore(__EMPTY);
        } else {
            result = (Pattern)optRestPatt;
        }
        Assoc[] assocs = (Assoc[])optTypedArray(assocList, Assoc.class);
        for (int i = assocs.length - 1; 0 <= i; i--) {
            EExpr keyExpr = forValue(assocs[i].key(), null);
            Object value = assocs[i].value();
            EExpr optDefaultExpr;
            Pattern valuePatt;
            if (value instanceof Pattern) {
                optDefaultExpr = null;
                valuePatt = (Pattern)value;
            } else {
                // XXX Must expand to handle 'default { e }' as well
                Assoc assoc = (Assoc)value;
                optDefaultExpr = (EExpr)assoc.key(); //may be null
                if (null != optDefaultExpr) {
                    optDefaultExpr = forValue(optDefaultExpr, null);
                }
                valuePatt = (Pattern)assoc.value();
            }
            EExpr viaFunc;
            if (null == optDefaultExpr) {
                // via (__extract(keyExpr)) [valuePatt, result]
                viaFunc = call(__EXTRACT, NO_POSER, "run", list(keyExpr));
            } else {
                // via (__extract.depr(keyExpr,
                //                     optDefaultExpr)) [valuePatt, result]
                viaFunc = call(__EXTRACT,
                               NO_POSER,
                               "depr",
                               list(keyExpr, optDefaultExpr));
            }
            result = via(viaFunc, listPattern(list(valuePatt, result)));
        }
        return result;
    }

    /**
     *
     */
    public Assoc assoc(Object key, Object value) {
        return new Assoc(key, value);
    }

    /**
     *
     */
    public Assoc exporter(Object nameExpr) {
        if (nameExpr instanceof SlotExpr) {
            NounExpr noun = ((SlotExpr)nameExpr).getNoun().asNoun();
            return assoc(literal("&" + noun.getName()), nameExpr);
        }
        NounExpr noun = (NounExpr)nameExpr;
        return assoc(literal(noun.getName()), nameExpr);
    }

    /**
     *
     */
    public Assoc importer(Object namerPatt) {
        Pattern namer;
        if (namerPatt instanceof Pattern) {
            namer = (Pattern)namerPatt;
        } else {
            Assoc assoc = (Assoc)namerPatt;
            namer = (Pattern)assoc.value();
        }
        String optName = namer.getOptName();
        if (null == optName) {
            syntaxError(namer, "Name expected in pattern");
        }
        if (namer instanceof SlotPattern) {
            optName = "&" + optName;
        }
        return assoc(literal(optName), namerPatt);
    }

    /**
     *
     */
    public EExpr mod(Object val, Object poser, Object nModulus) {
        if (val instanceof CallExpr) {
            CallExpr ce = (CallExpr)val;
            EExpr[] args = ce.getArgs();
            EExpr[] moduli = optExprs(nModulus);
            if ("pow".equals(ce.getVerb()) && 1 == args.length &&
              1 == moduli.length) {
                EExpr base = ce.getRecipient();
                EExpr exp = args[0];
                return call(base, poser, "modPow", list(exp, moduli[0]));
            }
        }
        return call(val, poser, "mod", nModulus);
    }

    /**
     *
     */
    public MsgPatt methHead(Object poser,
                            String verb,
                            Object patts,
                            Object optResultGuard) {
        return methHead(ident(poser, verb), patts, optResultGuard);
    }

    /**
     *
     */
    public EMethod to(Object doco, Object msgPatt, Object bodyExpr) {
        if (ConstMap.testProp(myProps, "e.enable.easy-return")) {
            bodyExpr = sequence(bodyExpr, NULL);
        }
        return method(doco,
                      msgPatt,
                      escape(finalPattern("__return"), bodyExpr, null));
    }

    /**
     * For defining an eScript that consists of exactly one method
     */
    private EScriptDecl methScriptDecl(Object msgPatt,
                                       Object bodyExpr,
                                       boolean bindReturn) {
        EMethod methNode = bindReturn ?
          to("", msgPatt, bodyExpr) :
          method("", msgPatt, bodyExpr);
        return vTable(list(methNode), list());
    }

    /**
     * For defining an eScript that consists of exactly one method
     */
    public ConstMap methDecl(Object msgPatt,
                            Object bodyExpr,
                            boolean bindReturn) {
        EScriptDecl script = methScriptDecl(msgPatt, bodyExpr, bindReturn);
        return ConstMap.fromPairs(new Object[][]{
                 { "script", script }});
    }

    public ConstMap fnDecl(Object poser, Object params, Object bodyExpr) {
        return methDecl(methHead(poser, "run", params, null),
                        bodyExpr,
                        false);
    }

    /**
     * Add extra ejector parameter and move param patterns, in order to address
     * bug <a href=
"https://sourceforge.net/tracker/index.php?func=detail&aid=1593160&group_id=75274&atid=551529"
     * >Change lambda-args expansion</a>
     */
    private ConstMap blockDecl(Object poser,
                               EList patternList,
                               Object bodyExpr) {
        int nPatterns = patternList.size();
        EList params = list();
        EList args = list();
        for (int i = 0; i < nPatterns; i++) {
            Astro p1 = newTemp("p");
            params = with(params, finalPattern(p1));
            args = with(args, noun(p1));
        }
        Astro ej2 = newTemp("ej");
        params = with(params, finalPattern(ej2));
        EExpr body = sequence(define(listPattern(patternList),
                                     noun(ej2),
                                     tuple(args)),
                              bodyExpr);
        return fnDecl(poser, params, body);
    }

    /**
     *
     */
    public EExpr control(Object recip,
                         Object sep,
                         Object params,
                         Object body) {
        EList paramList = (EList)params;
        int nParams = paramList.size();
        ConstMap blockFunc;
        String suffix;
        if (0 == nParams) {
            blockFunc = fnDecl(sep, paramList, body);
            suffix = "";
        } else {
            blockFunc = blockDecl(sep, paramList, body);
            suffix = "ej";
        }
        // XXX refactor: above block is identical to that in control/5

        EExpr lam = doco("", blockFunc);
        String verb = idStr(sep) + "__control_" + nParams + suffix;
        return call(recip, sep, verb, list(lam));
    }

    /**
     *
     */
    public EExpr control(Object recip,
                         Object sep,
                         Object args,
                         Object params,
                         Object body) {
        EList paramList = (EList)params;
        int nParams = paramList.size();
        ConstMap blockFunc;
        String suffix;
        if (0 == nParams) {
            blockFunc = fnDecl(sep, paramList, body);
            suffix = "";
        } else {
            blockFunc = blockDecl(sep, paramList, body);
            suffix = "ej";
        }
        // XXX refactor: above block is identical to that in control/4

        EExpr lam = doco("",
                         fnDecl(sep,
                                list(),
                                tuple(list(tuple(args),
                                           doco("", blockFunc)))));
        int nArgs = ((EList)args).size();
        String verb =
          idStr(sep) + "__control_" + nArgs + "_" + nParams + suffix;
        return call(recip, sep, verb, list(lam));
    }

    private AuditorExprs takeAuditorExprs(FlexMap decl) {
        return new AuditorExprs(null,
                                (EExpr)optTake(decl, "as"),
                                takeExprs(decl, "impls"),
                                null);
    }

    /**
     *
     */
    public EExpr doco(Object doco, Object oDecl) {
        if (oDecl instanceof EExpr) {
            // XXX deprecated case, still used by interface decls
            // looses the doco
            return (EExpr)oDecl;
        }
        FlexMap decl = ((ConstMap)oDecl).diverge();
        EExpr result = object(docComment(doco),
                              (Pattern[])optTake(decl, "oName"),
                              (EExpr)optTake(decl, "extends"),
                              takeAuditorExprs(decl),
                              (EScriptDecl)take(decl, "script"));
        T.require(decl.size() == 0, "internal: unconsumed attrs");
        return result;
    }

    private EExpr object(String docComment,
                         Pattern[] optOName,
                         EExpr optSuperExpr,
                         AuditorExprs auditors,
                         EScriptDecl script) {
        if (null == optOName) {
            return object(docComment,
                          ignoreOName(),
                          optSuperExpr,
                          auditors,
                          script);
        }
        if (1 == optOName.length) {
            GuardedPattern guarded = (GuardedPattern)optOName[0];
            if (null != guarded.getOptGuardExpr()) {
                syntaxError(guarded, "self-variable may not be guarded");
            }
            if (null == optSuperExpr) {
                //base case
                return super.object(docComment,
                                    guarded,
                                    auditors,
                                    script.makeEScript(this));
            }
            //The Tribble inheritance pattern
            script = script.withMatcher(delegatex(noun("super")));
            EExpr defobj = sequence(kdef(finalPattern("super"), optSuperExpr),
                                    object(docComment,
                                           optOName,
                                           null,
                                           auditors,
                                           script));
            if (guarded instanceof VarPattern) {
                String optName = guarded.getOptName();
                T.notNull(optName, "internal");
                NounExpr self = noun(optName);
                return sequence(define(slotPattern(optName),
                                       hide(sequence(defobj,
                                                     slotExpr(guarded,
                                                              self)))), self);
            }
            return define(guarded, hide(defobj));
        }
        if (2 == optOName.length) {
            return define(optOName[0],
                          hide(object(docComment,
                                      new Pattern[]{optOName[1]},
                                      optSuperExpr,
                                      auditors,
                                      script)));
        }
        T.fail("internal: Unexpected oName: " + E.toString(optOName));
        return null; // make the compiler happy
    }

    /**
     *
     */
    public EExpr defaultOptResultGuard(Object poser) {
        antiPocket(poser, "explicit-result-guard");
        if (ConstMap.testProp(myProps, "e.enable.easy-return")) {
            return null;
        }
        return VOID;
    }

    /**
     *
     */
    public EExpr defaultOptWhenGuard(Object poser) {
        antiPocket(poser, "explicit-result-guard");
//      XXX use instead: antiPocket(poser, "explicit-when-guard");
        if (ConstMap.testProp(myProps, "e.enable.easy-return")) {
            return null;
        }
        return VOID;
    }

    /**
     *
     */
    public Pattern patternEquals(Object eExpr) {
        return via(call(__IS, NO_POSER, "run", list(eExpr)), ignore());
    }

    /**
     *
     */
    public EExpr quasiExpr(Object syntax, Object quasiList) {
        Object[] qList = optTypedArray(quasiList, Object.class);
        StringBuffer buf = new StringBuffer();
        FlexList exprs = FlexList.make();

        for (int i = 0; i < qList.length; i++) {
            if (EParser.isQuasiPart(qList[i])) {
                buf.append(((Astro)qList[i]).getOptArgData());

            } else {
                EExpr eExpr = forValue(qList[i], null);
                buf.append("${").append(exprs.size()).append("}");
                exprs.push(eExpr);
            }
        }
        String str = buf.toString();
        LiteralExpr template = literal(str);
        EExpr valueMaker =
          call(syntax, NO_POSER, "valueMaker", list(template));
        return call(valueMaker, NO_POSER, "substitute", list(tuple(exprs)));
    }

    /**
     *
     */
    public Pattern quasiPattern(Object syntax, Object quasiList) {
        Object[] qList = optTypedArray(quasiList, Object.class);
        StringBuffer buf = new StringBuffer();
        FlexList exprs = FlexList.make();
        FlexList patts = FlexList.make();

        for (int i = 0; i < qList.length; i++) {
            if (EParser.isQuasiPart(qList[i])) {
                buf.append(((Astro)qList[i]).getOptArgData());

            } else if (qList[i] instanceof EExpr) {
                EExpr eExpr = forValue(qList[i], null);
                buf.append("${").append(exprs.size()).append("}");
                exprs.push(eExpr);

            } else {
                Pattern patt = (Pattern)qList[i];
                buf.append("@{").append(patts.size()).append("}");
                patts.push(patt);
            }
        }
        String str = buf.toString();
        LiteralExpr template = literal(str);
        EExpr matchMaker =
          call(syntax, NO_POSER, "matchMaker", list(template));

        return via(call(__MATCHBIND,
                        NO_POSER,
                        "run",
                        list(matchMaker, tuple(exprs))), listPattern(patts));
    }

    /**
     * $$ expands to ${0}
     */
    public QuasiLiteralExpr quasiLiteralExpr() {
        return new QuasiLiteralExpr(null, 0, null);
    }

    /**
     *
     */
    public QuasiLiteralExpr quasiLiteralExpr(Object optLitIndex) {
        if (null == optLitIndex) {
            return new QuasiLiteralExpr(null, 0, null);
        }
        Astro lit = (Astro)optLitIndex;
        int index = ((Number)lit.getOptData()).intValue();
        return new QuasiLiteralExpr(null, index, null);
    }

    /**
     *
     */
    public QuasiLiteralPatt quasiLiteralPatt(Object litIndex) {
        Astro lit = (Astro)litIndex;
        int index = ((Number)lit.getOptData()).intValue();
        return new QuasiLiteralPatt(null, index, null);
    }

    /**
     *
     */
    public QuasiPatternExpr quasiPatternExpr(Object litIndex) {
        Astro lit = (Astro)litIndex;
        int index = ((Number)lit.getOptData()).intValue();
        return new QuasiPatternExpr(null, index, null);
    }

    /**
     *
     */
    public QuasiPatternPatt quasiPatternPatt(Object litIndex) {
        Astro lit = (Astro)litIndex;
        int index = ((Number)lit.getOptData()).intValue();
        return new QuasiPatternPatt(null, index, null);
    }

    /**
     *
     */
    public EExpr same(Object x, Object poser, Object y) {
        return call(EQUALIZER, poser, "sameEver", list(x, y));
    }

    /**
     *
     */
    public EExpr sequence(Object x, Object y) {
        T.notNull(y, "internal: legacy of old return-value syntax");
        return sequence(new EExpr[]{forFxOnly(x, null), forValue(y, null)});
    }

    /**
     *
     */
    public EExpr sequence(Object x, Object y, Object z) {
        return sequence(new EExpr[]{forFxOnly(x, null),
          forFxOnly(y, null),
          forValue(z, null)});
    }

    /**
     *
     */
    private EExpr hide(Pattern[] typeParams, Object body) {
        for (int i = typeParams.length - 1; 0 <= i; i--) {
            body = sequence(kdef(typeParams[i], ANY), body);
        }
        return hide(body);
    }

    /**
     * switch (eExpr) { match pattern1 { body1 } match pattern2 { body2 } }
     * expands to { def temp = eExpr if (temp =~ pattern1) { body1 } else if
     * (temp =~ pattern2) { body2 } else { throw("no match: " + E.toQuote(temp)) } }
     */
    public EExpr switchx(Object specimen, Object matchers) {
        EMatcher[] mtchrs =
          (EMatcher[])optTypedArray(matchers, EMatcher.class);
        Astro tempName = newTemp("specimen");
        EExpr defTemp = kdef(finalPattern(tempName), specimen);
        return hide(sequence(defTemp, matchExpr(mtchrs, tempName, null)));
    }

    /**
     *
     */
    private EExpr matchExpr(EMatcher[] matchers,
                            Astro varName,
                            EExpr optOtherwise) {
        NounExpr specimen = noun(varName);
        EExpr result;

        if (null == optOtherwise) {
            EExpr[] quoteArgs = {specimen};
            EExpr quotedSpecimen = call(EE, NO_POSER, "toQuote", quoteArgs);

            EExpr str = literal("no match: ");
            EExpr[] addArgs = {quotedSpecimen};
            EExpr[] runArgs = {call(str, NO_POSER, "add", addArgs)};
            result = call(THROW, NO_POSER, "run", runArgs);

        } else {
            result = optOtherwise;
        }
        for (int i = matchers.length - 1; 0 <= i; i--) {
            result = ifx(matchBind(specimen,
                                   NO_POSER,
                                   matchers[i].getPattern()),
                         matchers[i].getBody(),
                         result);
        }
        return result;
    }

    /**
     *
     */
    EMatcher optMatcher(Object optMatchers) {
        EMatcher[] optMtchrs =
          (EMatcher[])optTypedArray(optMatchers, EMatcher.class);
        if (null == optMtchrs || 0 == optMtchrs.length) {
            return null;
        } else if (1 == optMtchrs.length) {
            return optMtchrs[0];
        } else {
            Astro tempName = newTemp("specimen");
            return matcher(finalPattern(tempName),
                           matchExpr(optMtchrs, tempName, null));
        }
    }

    /**
     * [x, y, z]       expands to  __makeList(x, y, z)
     */
    public EExpr tuple(Object argList) {
        return call(MAKE_LIST, NO_POSER, "run", argList);
    }

    /**
     * uriToken must be a URI, and have both protocol and body.
     * <p/>
     * &lt;http:foo&gt; expands to http__uriGetter["foo"]. &lt;x:foo&gt;
     * expands to file__uriGetter["x:foo"].
     */
    public EExpr uriExpr(Object uriToken) {
        Twine uriText = (Twine)((Astro)uriToken).getOptArgData(EParser.URI);
        String protocol = URIKit.getProtcol(uriText).bare();
        String body = URIKit.getBody(uriText).bare();
        if (1 == protocol.length()) {
            char c = Character.toLowerCase(protocol.charAt(0));
            if ('a' <= c && 'z' >= c) {
                protocol = "file";
                body = c + ":" + body;
            }
        }
        SimpleNounExpr getterNoun = new SimpleNounExpr(optSpan(uriToken),
                idStr(protocol + "__uriGetter"),
                null);
        return call(getterNoun,
                    uriToken,
                    "get",
                    list(literal(body)));
    }

    /**
     * The while loop expands as follows:
     * <p/>
     * while (cond) { body }   expands to
     * <p/>
     * escape __break { __loop( def _() :boolean { if (cond) { escape
     * __continue { body } true } else { false } }) }
     */
    public EExpr whilex(Object condExpr, Object bodyExpr, Object optCatcher) {
        EExpr methBody = ifx(condExpr,
                             sequence(escape(finalPattern("__continue"),
                                             bodyExpr,
                                             null), TRUE),
                             FALSE);
        EExpr meth = doco(" While loop body ",
                          methDecl(methHead(NO_POSER, "run", list(), BOOLEAN),
                                   methBody,
                                   false));

        return escape(finalPattern("__break"),
                      call(LOOP, NO_POSER, "run", list(meth)),
                      optCatcher);
    }

    /**
     *
     */
    public EExpr tryx(Object eExpr, Object optCatchers, Object optFinally) {
        EMatcher optCatcher = optMatcher(optCatchers);
        if (null == optCatcher) {
            if (null == optFinally) {
                return hide(eExpr);
            }
            return super.tryx(eExpr, null, optFinally);
        }
        EExpr result = super.tryx(eExpr, optCatcher, null);
        if (null == optFinally) {
            return result;
        }
        return super.tryx(result, null, optFinally);
    }

    /**
     * Then when statement base-case expands as follows:
     * <pre>    when (eExpr) -> done(patt1) :resultGuard {
     *        body1
     *    } catch ... {
     *        ...
     *    } ... # possibly more catches & a finally clause</pre>
     * expands to
     * <pre>    { Ref whenResolved(eExpr, def done(resolution) :resultGuard {
     *        try {
     *            Ref.fulfillment(resolution) into patt1
     *            body1
     *        } catch ... {
     *            ...
     *        } ... # possibly more catches & a finally clause
     *    })}</pre>
     * This causes one irregularity: Any definitions introduced by eExpr, as
     * well as the definition of the done function itself, are visible from the
     * catch claueses and the finally clause, whereas, by normal E scoping
     * rules, they should only be visible from patt1 and body1.
     */
    private EExpr whenBase(EExpr eExpr,
                           Pattern[] optOName,
                           Object poser,
                           Pattern patt1,
                           EExpr resultGuard,
                           EExpr body1,
                           Object catchers,
                           Object optFinally,
                           boolean bindReturn) {
        Astro resolution = newTemp("resolution");
        EExpr resExpr = noun(resolution);
        Pattern resPatt = finalPattern(resolution);

        EExpr rValue = call(REF, NO_POSER, "fulfillment", list(resExpr));
        body1 =
          tryx(sequence(kdef(patt1, rValue), body1), catchers, optFinally);
        EScriptDecl script = methScriptDecl(methHead(poser,
                                                     "run",
                                                     list(resPatt),
                                                     resultGuard),
                                            body1,
                                            bindReturn);
        return hide(call(REF,
                         NO_POSER,
                         "whenResolved",
                         list(eExpr,
                              doco(" when-catch 'done' function ",
                                   ConstMap.fromPairs(new Object[][]{
                                     { "oName", optOName },
                                     { "script", script }})))));
    }

    /**
     * Then normal when statement syntax expands as follows:
     * <pre>
     *    when (eExprs,...) -> done(optPatts,...) :resultGuard {
     *        body1
     *    } catch patt2 {
     *        body2
     *    }
     * </pre>
     * eExprs and optPatts must have the same arity, which must be >=1. If it's
     * exactly 1, the we use the above base case. Otherwise we expand to
     * <pre>
     *    when (promiseAllFulfilled([eExprs,...]) ->
     *            done([optPatts,...]) :resultGuard {
     *        body1
     *    } catch patt2 {
     *        body2
     *    }
     * </pre>
     * which then expands according to the base case explained in {@link
     * #whenBase}
     */
    private EExpr whenList(EExpr[] eExprs,
                           Pattern[] optOName,
                           Object poser,
                           Pattern[] optPatts,
                           EExpr resultGuard,
                           EExpr body1,
                           Object catchers,
                           Object optFinally,
                           boolean bindReturn) {
        int len = eExprs.length;
        if (0 >= len) {
            syntaxError(poser, "must list at least one expression");
        }
        if (null != optPatts && len != optPatts.length) {
            syntaxError(poser,
                        "must have same number of expressions and patterns");
        }

        EExpr eExpr;
        if (1 == len) {
            eExpr = eExprs[0];
        } else {
            eExpr =
              call(PROMISE_ALL_FULFILLED, poser, "run", list(tuple(eExprs)));
        }
        Pattern patt1;
        if (null == optPatts) {
            patt1 = ignore();
        } else if (1 == len) {
            patt1 = optPatts[0];
        } else {
            patt1 = listPattern(optPatts);
        }
        return whenBase(eExpr,
                        optOName,
                        poser,
                        patt1,
                        resultGuard,
                        body1,
                        catchers,
                        optFinally,
                        bindReturn);
    }

    /**
     * A left-out when-catch-clause defaults to always retrow.
     * <pre>    when ... -> ... { ... }</pre>
     * expands to
     * <pre>    when ... -> ... { ... } catch ex { throw(ex) }</pre>
     */
    public EList defaultWhenCatches(Object poser) {
        Astro ex = newTemp("ex");
        EMatcher catcher =
          matcher(finalPattern(ex), call(THROW, poser, "run", list(noun(ex))));
        return list(catcher);
    }

    /**
     *
     */
    public EExpr when(Object exprs, Object poser, Object tailMap) {
        FlexMap tails = ((ConstMap)tailMap).diverge();
        EExpr body1 = forValue((EExpr)take(tails, "whenBody"),
                               StaticScope.EmptyScope);
        EList optCatches = (EList)optTake(tails, "whenCatches");
        if (null == optCatches) {
            optCatches = defaultWhenCatches(poser);
        }
        EExpr optFinally = (EExpr)optTake(tails, "whenFinally");
        if (null != optFinally) {
            optFinally = forValue(optFinally, StaticScope.EmptyScope);
        }
        EExpr result = whenList(optExprs(exprs),
                                (Pattern[])optTake(tails, "oName"),
                                poser,
                                (Pattern[])optTypedArray(optTake(tails,
                                                                 "whenParams"),
                                                         Pattern.class),
                                (EExpr)optTake(tails, "whenGuard"),
                                body1,
                                optCatches,
                                optFinally,
                                null != (Boolean)optTake(tails,"bindReturn"));
        T.require(tails.size() == 0, "internal: unconsumed attributes");
        return result;
    }

    /**
     *
     */
    public EExpr whenSeq(Object exprs, Object poser, Object whenRest) {
        return whenList(optExprs(exprs),
                        null,
                        poser,
                        null,
                        null,
                        forValue(whenRest, StaticScope.EmptyScope),
                        defaultWhenCatches(poser),
                        null,
                        false);
    }

    /**
     *
     */
    public EExpr oType(Object doco,
                       Object optOName,
                       Object typeParams,
                       Object mTypes) {
        return oType(doco,
                     optOName,
                     typeParams,
                     null,
                     ConstMap.EmptyMap,
                     mTypes);
    }

    /**
     *
     */
    public EExpr oType(Object doco,
                       Object optOName,
                       Object typeParams,
                       Object optAudit,
                       Object objDecl,
                       Object mTypes) {
        FlexMap decl = ((ConstMap)objDecl).diverge();
        EExpr result = oType(literal(docComment(doco)),
                             optOName,
                             optPatterns(typeParams),
                             (Pattern)optAudit,
                             tuple(takeExprs(decl, "supers")),
                             tuple(takeExprs(decl, "impls")),
                             tuple(mTypes));
        T.require(decl.size() == 0, "internal: unconsumed attributes");
        return result;
    }

    /**
     *
     */
    private EExpr oType(LiteralExpr docComment,
                        Object optOName,
                        Pattern[] typeParams,
                        Pattern optAuditorPatt,
                        EExpr superTuple,
                        EExpr auditorTuple,
                        EExpr msgTuple) {
        if (optOName instanceof EExpr) {
            //base case 1
            return oTypeBase(docComment,
                             null,
                             typeParams,
                             optAuditorPatt,
                             forValue(optOName, null),
                             superTuple,
                             auditorTuple,
                             msgTuple);

        } else if (optOName instanceof String) {
            return oType(docComment,
                         literal(optOName),
                         typeParams,
                         optAuditorPatt,
                         superTuple,
                         auditorTuple,
                         msgTuple);

        } else if (EParser.isLiteralToken(optOName)) {
            String qualifiedName = ((Astro)optOName).getOptString();
            T.notNull(qualifiedName,
                      "Internal: Missing qualified name: ",
                      optOName);
            return oType(docComment,
                         literal(qualifiedName),
                         typeParams,
                         optAuditorPatt,
                         superTuple,
                         auditorTuple,
                         msgTuple);

        } else {
            //base case 2
            Pattern[] oName = (Pattern[])optOName;
            // The name is derived from the last oName
            String optName = oName[oName.length - 1].getOptName();
            EExpr qualName;
            if (null == optName) {
                qualName = literal("_");
            } else {
                qualName = literal(optName + "__T");
            }
            qualName = call(call(doMeta("meta", "context", list()),
                                 "getFQNPrefix",
                                 list()), "add", list(qualName));
            // XXX Should we also have some meta way of declaring that this
            // qualName (with a "$") is the new fqnPrefix within the interface
            // expression?
            return oTypeBase(docComment,
                             oName[0],
                             // Match only the first oName pattern
                             typeParams,
                             optAuditorPatt,
                             qualName,
                             superTuple,
                             auditorTuple,
                             msgTuple);
        }
    }

    /**
     *
     */
    private EExpr oTypeBase(LiteralExpr docComment,
                            Pattern optOPatt,
                            Pattern[] typeParams,
                            Pattern optAuditorPatt,
                            EExpr qualName,
                            EExpr superTuple,
                            EExpr auditorTuple,
                            EExpr msgTuple) {

        EList args =
          list(docComment, qualName, superTuple, auditorTuple, msgTuple);
        if (null == optAuditorPatt) {
            if (null == optOPatt) {
                return hide(typeParams,
                            call(MAKE_PROT, NO_POSER, "run", args));
            }
            return define(optOPatt,
                          hide(typeParams,
                               call(MAKE_PROT, NO_POSER, "run", args)));
        }
        if (null == optOPatt) {
            optOPatt = ignore();
        }
        return call(define(listPattern(list(optOPatt, optAuditorPatt)),
                           hide(typeParams,
                                call(MAKE_PROT,
                                     NO_POSER,
                                     "makePair",
                                     args))),
                    NO_POSER,
                    "get",
                    list(literal(EInt.valueOf(0))));
    }

    /**
     *
     */
    public EExpr mType(Object doco,
                       Object verb,
                       Object pTypes,
                       Object optRetType) {
        if (null == optRetType) {
            optRetType = VOID;
        }
        return hide(call(MAKE_MSG,
                         NO_POSER,
                         "run",
                         list(literal(docComment(doco)),
                              litStr(verb),
                              tuple(pTypes),
                              optRetType)));
    }

    /**
     *
     */
    public EExpr pType(Object optName, Object optType) {
        EExpr nameExpr;
        if (null == optName) {
            nameExpr = NULL;
        } else {
            nameExpr = litStr(optName);
        }
        if (null == optType) {
            optType = ANY;
        }
        return call(MAKE_PARAM, NO_POSER, "run", list(nameExpr, optType));
    }

    /**
     *
     */
    public LiteralExpr litStr(Object optName) {
        return literal(idStr(optName));
    }

    /**
     *
     */
    public EExpr callFacet(Object recipientExpr, Object vcurry) {
        return call(__MAKE_VERB_FACET,
                    "curryCall",
                    list(recipientExpr, litStr(vcurry)));
    }

    /**
     *
     */
    public EExpr sendFacet(Object recipientExpr, Object vcurry) {
        return call(__MAKE_VERB_FACET,
                    "currySend",
                    list(recipientExpr, litStr(vcurry)));
    }

    /**
     *
     */
    public EExpr propSlot(Object recipientExpr, Object propName) {
        return call(recipientExpr,
                    "__getPropertySlot",
                    list(litStr(propName)));
    }

    /**
     *
     */
    public EExpr propValue(Object recipientExpr, Object propName) {
        return call(propSlot(recipientExpr, propName), "get", list());
    }

    /**
     *
     */
    public EExpr sendPropSlot(Object recipientExpr, Object propName) {
        return send(recipientExpr,
                    "__getPropertySlot",
                    list(litStr(propName)));
    }

    /**
     *
     */
    public EExpr sendPropValue(Object recipientExpr, Object propName) {
        return send(sendPropSlot(recipientExpr, propName), "get", list());
    }

    /**
     *
     */
    public Pattern cdrPattern(Object subs, Object rest) {
        FlexList patts = (FlexList)subs;
        int size = patts.size();
        patts = with(patts, rest);
        return via(call(__SPLITLIST,
                        NO_POSER,
                        "run",
                        list(literal(EInt.valueOf(size)))),
                   listPattern(patts));
    }

    /**
     *
     */
    public Pattern suchThat(Object pattern, Object condExpr) {
        return via(__SUCHTHAT,
                   listPattern(list(pattern,
                                    via(call(__SUCHTHAT,
                                             NO_POSER,
                                             "run",
                                             list(condExpr)), ignore()))));
    }

    /**
     *
     */
    public Pattern finalPattern(Object atom) {

        if (atom instanceof QuasiLiteralExpr) {
            QuasiLiteralExpr qle = (QuasiLiteralExpr)atom;
            return new QuasiLiteralPatt(qle.getOptSpan(), qle.index(), null);

        } else if (atom instanceof QuasiPatternExpr) {
            QuasiPatternExpr qpe = (QuasiPatternExpr)atom;
            return new QuasiPatternPatt(qpe.getOptSpan(), qpe.index(), null);

        } else {
            return finalPattern(atom, null);
        }
    }

    public Pattern varPattern(Object atom) {
        return varPattern(atom, null);
    }

    public Pattern slotPattern(Object atom) {
        return slotPattern(atom, null);
    }

    public Pattern ignore() {
        return ignore(null);
    }

    public Pattern bindDefiner(Object identOrStr) {
        return bindDefiner(identOrStr, null);
    }

    public Pattern bindDefiner(Object identOrStr, Object optGuardExpr) {
        Astro name = ident(identOrStr);
        Astro nameR = mangle(name, "__Resolver");
        EList args;
        if (null == optGuardExpr) {
            args = list(noun(nameR));
        } else {
            args = list(noun(nameR), optGuardExpr);
        }
        return via(call(__BIND, identOrStr, "run", args), ignore());
    }

    public Pattern[] finalOName(Object atom) {
        return new Pattern[]{finalPattern(atom)};
    }

    public Pattern[] varOName(Object atom) {
        return new Pattern[]{varPattern(atom)};
    }

    public Pattern[] ignoreOName() {
        return new Pattern[]{ignore()};
    }

    public Pattern[] bindOName(Object identOrStr) {
        // XXX BUG: Need to expand to something else
        return new Pattern[]{bindDefiner(identOrStr),
          finalPattern(identOrStr)};
    }

    /**
     *
     */
    public EExpr cast(Object expr, Object poser, Object guardExpr) {
        return call(call(GUARD, "coerce", list(guardExpr, NULL)),
                    poser,
                    "coerce",
                    list(expr, NULL));
    }

    /**
     *
     */
    public EExpr condAnd(Object left, Object poser, Object right) {
        return new CondAndExpr(null, (EExpr)left, (EExpr)right, null);
    }

    /**
     *
     */
    public EExpr condOr(Object left, Object poser, Object right) {
        return new CondOrExpr(null, (EExpr)left, (EExpr)right, null);
    }

    /**
     *
     */
    public EExpr matchBind(Object specimen, Object poser, Object pattern) {
        return new MatchBindExpr(null,
                                 forValue(specimen, null),
                                 (Pattern)pattern,
                                 null);
    }

    public EExpr ifx(Object condExpr, Object thenExpr, Object elseExpr) {
        if (condExpr instanceof DelayedExpr) {
            DelayedExpr de = (DelayedExpr)condExpr;
            EExpr thn = forValue(thenExpr, StaticScope.EmptyScope);
            Astro ej1 = newTemp("ej");
            return escape(finalPattern(ej1),
                          sequence(de.forControl(this, ej1, thn.staticScope()),
                                   thn),
                          ignore(),
                          elseExpr);
        }
        return super.ifx(condExpr, thenExpr, elseExpr);
    }

    public EExpr forValue(Object optExpr, StaticScope optUsed) {
        if (null == optExpr) {
            return null;
        } else if (optExpr instanceof DelayedExpr) {
            return ((DelayedExpr)optExpr).forValue(this, optUsed);
        } else {
            return (EExpr)optExpr;
        }
    }

    public EExpr forFxOnly(Object optExpr, StaticScope optUsed) {
        if (null == optExpr) {
            return null;
        } else if (optExpr instanceof DelayedExpr) {
            return ((DelayedExpr)optExpr).forFxOnly(this, optUsed);
        } else {
            return (EExpr)optExpr;
        }
    }

    public EExpr forControl(Object optExpr, Astro optEj, StaticScope optUsed) {
        if (null == optExpr) {
            return null;
        } else if (optExpr instanceof DelayedExpr) {
            return ((DelayedExpr)optExpr).forControl(this, optEj, optUsed);
        } else {
            return kerneldef(ignore(__TEST), noun(optEj), optExpr);
        }
    }

    /**
     *
     */
    public Pattern callPattern(Object target,
                               Object poser,
                               String verb,
                               Object params) {
        return callPattern(target, ident(poser, verb), params);
    }

    /**
     *
     */
    public Pattern callPattern(Object target, Object verb, Object params) {
        Pattern[] patts = optPatterns(params);
        String mverb = "match__" + idStr(verb) + "_" + patts.length;
        return via(callFacet(target, ident(verb, mverb)), listPattern(patts));
    }
}
